#+TITLE: babel
#+SETUP_FILE: ~/shed/src/meta/ox.setup
#+PROPERTY: header-args :eval never-export
* snippet
** rust-target-triple
 #+name: rust-target-triple
 #+begin_src shell
 rustc -vV | sed -n -e 's/^host: //p'
 #+end_src

** make-header
#+name: make-header
#+begin_src makefile
MAKEFLAGS += --warn-undefined-variables
.DELETE_ON_ERROR:
#+end_src
** make-list
 #+name: make-list
 #+begin_src makefile
 _list: #requires xargs awk egrep
	 @$(MAKE) -pRrq -f ; \
	 $(lastword $(MAKEFILE_LIST)) : \
		 2>/dev/null | awk -v RS= -F: \
		 '/^# File/,/^# Finished Make data base/ {if ($$1 !~ "^[#.]") {print $$1}}' \
		 | sort | egrep -v -e '^[^[:alnum:]]' -e '^$@$$' | xargs
 #+end_src
** make-demon
 #+name: make-demon
 #+begin_src makefile
 .EXPORT_ALL_VARIABLES:
 DEMON:=$(shell echo ${USER} | tr 'A-Za-z' 'N-ZA-Mn-za-m')dm
 STAMP:=$(STAMP)

 .PHONY: _dmadd _dmkill

 _dmadd:useradd $(DEMON) -G demon;\
   mkdir -p $(STAMP)/dm/.h/$(DEMON);\
   chown -R $(DEMON):demon $(STAMP)/dm/.h/$(DEMON);\
   install -C -m 775 -o $(DEMON) -g demon $(STAMP) $(STAMP)/dm/.h/$(DEMON)

 _dmkill:userdel -f -r $(DEMON);\
   rm -rf $(STAMP)/dm/.h/$(DEMON)

 .DEFAULT_GOAL := #reset default

 #+end_src

** js-copy-link-id
#+name: copy-link-id
#+begin_src js
function Copy() {
  var Url = document.getElementById("url_id");
  Url.innerHTML = window.location.href;
  console.log(Url.innerHTML)
  Url.select();
  document.execCommand("copy");
}
#+end_src

+ example -- \\
  #+begin_src html
<div>
  <input type="button" value="Copy Url" onclick="Copy();" />
  <br /> Paste: <textarea id="url_id" rows="1" cols="30"></textarea>
</div>
  #+end_src
** extract
#+name: extract(f)
#+begin_src sh
    if [ -f $f ] ; then
	case $f in
	    ,*.tar.bz2)        tar xjf $f        ;;
	    ,*.tar.gz)         tar xzf $f        ;;
	    ,*.bz2)            bunzip2 $f       ;;
	    ,*.rar)            unrar x $f        ;;
	    ,*.gz)             gunzip $f         ;;
	    ,*.tar)            tar xf $f         ;;
	    ,*.tbz2)           tar xjf $f        ;;
	    ,*.tgz)            tar xzf $f        ;;
	    ,*.zip)            unzip $f          ;;
	    ,*.Z)              uncompress $f     ;;
	    ,*.7z)             7zr e $f          ;;
	    ,*)                echo "'$f' cannot be extracted via extract()" ;;
	esac
    else
	echo "'$f' is not a valid file"
    fi
#+end_src
** git-clone
#+name: git-clone(src)
#+begin_src sh :results silent
  git clone $src
#+end_src
** hg-clone
#+name: hg-clone
#+begin_src sh :var remote=() :results silent
hg clone $remote
#+end_src
** hg-rev
#+name: hg-rev
#+begin_src sh :var src=(org-sbx org-current-heading-title)
cd ~/shed/src/$src && hg log -l 1 --template '{node|short}'
#+end_src
** hg-id-num
#+name: hg-id-num
#+begin_src shell :var src=(org-sbx org-current-heading-title)
cd ~/shed/src/$src && hg id -n
#+end_src

** hg-log-age
#+name: hg-log-age
#+begin_src shell :results output :var src=(org-sbx org-current-heading-title)
  cd ~/shed/src/$src && hg log -l1 --template "{date|age}"
#+end_src

** tokei-dir-lines
#+name: tokei-dir-lines
#+begin_src shell :var src=(org-sbx org-current-heading-title) :results raw
  cd ~/shed/src/$src
  input=`tokei -C -o json`
  echo $input | jq -r '.["Total"] | .code, .comments, .blanks'
#+end_src

** tokei-dir-langs
#+name: tokei-dir-langs
#+begin_src shell :var src=(org-sbx org-current-heading-title) :results raw
  cd ~/shed/src/$src
  input=`tokei -C -o json`
  echo $input | jq -r '.["Total"].children | keys[]'
#+end_src

** sum-str-nums
#+name: sum-str-nums
#+begin_src emacs-lisp :var s=tokei-dir-lines
  (let ((tot 0))
    (cl-loop
     for i in (split-string s) do
     (setq tot (+ tot (string-to-number i))))
    tot)
#+end_src

** shc-hg-summary
#+name: shc-hg-summary
#+begin_src sh :var p="meta" :results output
shc s -v ~/shed/src/$p
#+end_src
** org-current-h1-title
#+name: org-current-heading-title
#+begin_src emacs-lisp :results value
  (org-element-property :title (save-excursion (org-up-heading-safe) (org-element-at-point)))
#+end_src

** org-capture-stdout
#+name: org-capture-stdout
#+begin_src shell :tangle yes
  #!/bin/bash

  TITLE="$*"
  CONTENT="
       ,#+BEGIN_EXAMPLE
  $(cat | sed 's/^/     /g')
       ,#+END_EXAMPLE
  "

  if [[ -n $TITLE ]]
  then
      CONTENT="   - ${TITLE}\n${CONTENT}"
  fi

  /usr/local/bin/emacsclient -c -n \
                             -e "(progn (org-capture-string \"$CONTENT\" \"3\") (delete-frame))"
#+end_src

** org-task-tbl
#+name: org-task-tbl
#+begin_src emacs-lisp
  (let* ((ast (org-element-parse-buffer)) ;; built up the abstract syntax tree of the org buffer
         item-types ; all occuring item types. It could be that some task has more item types than another.
         tasks ; accumulation list for the tasks
         current-task ; name of the current task (header of level 1)
         task-items) ; items of the current task
    (org-element-map ast 'headline
      (lambda (hl)
        (cl-case (org-element-property :level hl)
          (1 ; We assume here that headers of level 1 are tasks.
           (when current-task ; registering the old task
             (setq tasks (cons (cons current-task (nreverse task-items)) tasks)))
           (setq current-task (org-element-property :raw-value hl) ; preparing the new task
                 task-items nil))
          (2 ; item
           (let ((item-type (org-element-property :raw-value hl)))
             (setq item-types (cons item-type item-types))
             (setq task-items (cons (cons item-type (org-element-property :todo-keyword hl))
                                    task-items)))))))
    (setq tasks (nreverse (cons (cons current-task (nreverse task-items)) tasks)) ;add the last task
          item-types (sort (cl-remove-duplicates (nreverse item-types) :test 'string-equal) ; list of unique item types
                           #'string<)) ;;Sorting the items lexicographical. Other criteria could be applied.
      ;;;;;;;;;;
    ;; generating the output table:
    (apply
     #'list
     (cons "Item" (mapcar #'car tasks)) ; header
     'hline
     ;; rows:
     (mapcar
      ;; mapping the items to the todo states associated to the tasks:
      (lambda (item-type)
        (cons item-type
              (mapcar
               (lambda (task)
                 (let ((todo-status (cdr (assoc-string item-type task))))
                   todo-status))
               tasks)))
      item-types)))
#+end_src

** shc-weather
print a quick forecast
#+name: shc-weather
#+begin_src sh :results output
shc s -w
#+end_src

** sh-ob-tangle
#+name: sh-ob-tangle
#+begin_src sh
  emacs -Q --batch --eval "
      (progn
	(require 'ob-tangle)
	(dolist (file command-line-args-left)
	  (with-current-buffer (find-file-noselect file)
	    (org-babel-tangle))))
    " "$@"
#+end_src
** wc-dir-lines
#+name: wc-dir-lines
#+begin_src shell :var dir="."
cd $dir && cat * | wc -l
#+end_src

** wc-dir-words
#+name: wc-dir-words
#+begin_src shell :var dir="."
cd $dir && cat * | wc -w
#+end_src
** env-table
#+name: env-table
#+begin_src sh :results silent
  for i in $(env);
  do
      echo "$i" | sed '0,/=/s//|/'
  done
#+end_src
** get-env
#+name: get-env
#+begin_src elisp :results silent :var key=""
(getenv key)
#+end_src
** org-headlines-map
#+name: org-headlines-map
#+begin_src elisp
  (org-element-map (org-element-parse-buffer 'headline )
      'headline
    (lambda(hl)
      (let ((parent (org-element-property :parent hl )))
        (and (eq (org-element-type parent) 'headline)
             (list (org-element-property :title parent) (org-element-property :title hl))))))

#+end_src

** get-emacs-version
#+name: get-emacs-version
#+begin_src elisp :results output
  (princ (concat (format "%s\n" (emacs-version))
		 (format "Org v%s" (org-version))))
#+end_src
** colsum-if
sum values in vallist if the corresponding key matches the keymatch
argument
#+name: colsum-if
#+begin_src elisp :var keylist=() vallist=() keymatch=()
  (cl-loop for key in keylist
	   for val in vallist
	   when (equal key keymatch)
	   sum (string-to-number val))
#+end_src
** load-file
#+name: load-file
#+begin_src elisp :var file=()
(load-file file)
#+end_src
** cp-f
#+name: cp-f
#+begin_src elisp :var in="file" out="path"
(copy-file in out)
#+end_src
** dot-version
#+begin_src sh
dot -V 2>&1
#+end_src

** make-dot-tree
#+name: make-dot-tree
#+begin_src emacs-lisp :var table=org-headlines-map :results output
  (mapcar #'(lambda (x)
		(princ (format "\"%s\" -> \"%s\";\n" (cl-first x) (cl-second x))))
	  table)
#+end_src

** gen-dot-tree
#+name: gen-dot-tree
#+begin_src dot :file /tmp/tree.png :cmdline -Kdot -Tpng :var input=make-dot-tree
digraph {
   rankdir=TB;
   splines=true;
   node [shape=box];
   $input
  }
#+end_src

* skeleton
** rust
*** bin
**** Cargo.toml
#+begin_src toml :var name=""
[package]
name = "$name"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src
**** rustfmt.toml
#+begin_src toml
edition = "2021"
reorder_imports = true
reorder_modules = true
tab_spaces = 2
use_field_init_shorthand = true
use_try_shorthand = true
#+end_src
**** src/main.rs
#+begin_src rust
fn main() {
  
}
#+end_src
*** lib
**** Cargo.toml
#+begin_src toml :var name="_lib"
[package]
name = "$name"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src
**** src/lib.rs
#+begin_src rust
#+end_src
*** mod-bin
**** Cargo.toml
#+begin_src toml :var name="_mod"
[package]
name = "$name"
version = "0.1.0"
edition = "2021"

[[bin]]
path = "main.rs"

[dependencies]
#+end_src
**** main.rs
#+begin_src rust
fn main() {}
#+end_src
*** mod-lib
**** Cargo.toml
#+begin_src toml :var name="_mod"
[package]
name = "$name"
version = "0.1.0"
edition = "2021"

[[lib]]
path = "lib.rs"

[dependencies]
#+end_src
**** lib.rs
#+begin_src rust
#+end_src
*** app
**** Cargo.toml
#+begin_src toml :var name="_app"
[package]
name = "$name"
version = "0.1.0"
edition = "2021"

[dependencies]
rlib = "0.1.0"
tenex = "0.1.0"
#+end_src
**** src/main.rs
#+begin_src rust
use rlib::ctx;

#[ctx::main]
async fn main() {}
#+end_src
** lab
*** rust-fu
#+name: rust-fu
#+begin_src elisp
#+end_src
*** sh-fu
#+name: sh-fu
#+begin_src elisp
#+end_src
*** windows-10-vm
*** archlinux-vm
** python
* script
** meta
*** make-info-tbl
#+name: meta-make-info-tbl
#+header: :var version="alpha-0.1"
#+header: :var name=(org-sbx org-current-heading-title)
#+header: :var dir="/home/ellis/shed/src/"
#+begin_src emacs-lisp :exports results :results table :eval no-export 
  (let* ((src (concat dir name))
         (age (org-sbe hg-log-age ''(dir src)))
         (rev (org-sbe hg-rev ''(dir src)))
         (num (org-sbe hg-id-num ''(dir src)))
         (cc1 (org-sbx tokei-dir-lines ''((dir src))))
         (cc2 (org-sbx tokei-dir-langs ''((dir src))))
         (nf (format "[[https://rwest.io/m#%s][%s]]" name name))
         (rf (format "[[https://hg.rwest.io/%s/rev/%s][%s:%s]]" name rev num rev))
         (gf (format "[[https://github.com/richardwesthaver/%s][github]]" name))
         (vf (format "%s, %s" rf gf))
         (lsum (org-sbe sum-str-nums ('s 'cc1)))
         (l (split-string cc1))
         (lang (split-string cc2))
         (cf (format "%s = λ:%s #:%s _:%s" lsum (pop l) (pop l) (pop l))))
    `(hline
      (name ,nf)
      (version ,version)
      (vc ,vf)
      (updated ,age)
      (lines ,cf)
      (langs ,lang)
      hline))
  #+end_src

*** make-includes
#+name: meta-make-includes
#+begin_src emacs-lisp :var i=()
`((includes ,i))
#+end_src

*** make-files-tbl
#+name: meta-ls-files
#+begin_src sh :results silent :exports none :var a=(expand-file-name "~/shed/src") b=(org-sbx org-current-heading-title)
  ls -lh $a/$b --time-style=long-iso \
    |awk '{if (NR!=1) print $8, $5, $6"-"$7}' \
    |awk 'BEGIN{print "file size updated"}{print $0}'
#+end_src

#+name: meta-make-files-tbl
#+begin_src python :var tab=meta-ls-files() :results table :colnames yes :hlines yes :exports results :eval no-export
return tab
#+end_src

** ytdl
#+name: ytdl
#+begin_src sh :var OUT_PATH=""
youtube-dl --no-warnings \
  -o '$OUT_PATH/%(title)s.%(ext)s' \
  --socket-timeout 15 --hls-use-mpegts -R 64 --fragment-retries 64 \
  --prefer-free-formats --all-subs --embed-subs \
  -f 'bestvideo[height<=1080]+bestaudio/best[height<=1080]' "$@" \
  --restrict-filenames
#+end_src

** cargo-update-dir
#+name: cargo-update-dir
#+begin_src sh :var dir=()
# update all crates in dir
set -eu
case $0 in
   (/*) dir=${0%/*}/;;
   (*/*) dir=./${0%/*};;
   (*) dir=.;;
esac

find "$dir/.." -name Cargo.lock -execdir cargo update \;
#+end_src

** wg-keygen
generate base64-enc keypair in current dir
#+name: wg-keygen
#+begin_src sh

umask 077
wg genkey | tee privatekey | wg pubkey > publickey
#+end_src
** rand
#+name: urand_4k_file
#+begin_src sh
# create 4k of random bytes in file
dd if=/dev/urandom of=$@ count=4 bs=1024
#+end_src

#+name: urand_stdout
#+begin_src sh
# generate random numbers to stdout
od -d /dev/urandom
#+end_src

#+name: urand-sha512
#+begin_src sh
# generate hash of 128 random bytes
dd if=/dev/urandom  count=1 bs=128 | sha512sum
#+end_src
** term-check
#+name: term-check
#+begin_src sh
stty -a #current settings of all terminal attributes
bind -p #key bindings
infocmp #print out a terminfo description
#+end_src

** virt
#+name: dd_write_iso
#+begin_src sh :var iso="" :var disk=""
dd bs=4M if=$iso of=$disk conv=fdatasync status=progress
#+end_src
*** qemu
#+name: qemu_init_win10
#+begin_src sh :var boot="win10_x64.iso" :var virt="win10.iso" :var disk="win10.img"
# this script requires an installation ISO (win10_x64.iso), the
# virtio-windows-guest drivers (win10.iso), and a fresh disk image to
# install to (win10.img).
#
# the graphic installer will boot and you then need to load the virtio
# drivers, at which point you can install as usual.
exec qemu-system-x86_64 -enable-kvm \
        -cpu host \
        -cdrom $boot \
        -drive file=$virt,if=virtio \
        -drive file=$disk,index=1,media=cdrom \
        -net nic,model=virtio -net user \
        -vga qxl \
        -m 4G \
        -monitor stdio \
        -name "Windows" \
        "$@"
#+end_src

** sys
*** systemd
#+name: systemctl_list_units
#+begin_src sh
systemctl list-units --state=running | grep -v systemd | awk '{print $1}' | grep service
#+end_src
*** inotify
#+name: inotify-watch-dir
#+begin_src sh :var dir="."
inotifywait -m  $path -e create -e moved_to |
    while read dir action file; do
	echo "The file '$file' appeared in directory '$dir' via '$action'"
    done
#+end_src
** os
*** macos
#+name: macos_init
#+begin_src sh
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
brew install openssl cmake
curl https://sh.rustup.rs -sSf | sh
source ~/.cargo/env
#+end_src
** http-server
#+name: http-server
#+begin_src python
from http.server import HTTPServer, SimpleHTTPRequestHandler, test
import sys

class RequestHandler(SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header('Cross-Origin-Opener-Policy', 'same-origin')
        self.send_header('Cross-Origin-Embedder-Policy', 'require-corp')
        SimpleHTTPRequestHandler.end_headers(self)

if __name__ == '__main__':
    test(RequestHandler, HTTPServer, port=int(sys.argv[1]) if len(sys.argv) > 1 else 8000)
#+end_src
